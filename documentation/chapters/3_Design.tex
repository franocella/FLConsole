\chapter{Design}

\section{Introduction}
This chapter aims to provide a detailed overview of the software architecture and database design of the project. It is essential for understanding the organization and structure of the system, as well as the design choices made to ensure the efficiency, scalability, and robustness of the software.

The design of the software architecture focuses on the organization and distribution of software components, defining roles, responsibilities, and interactions among them. Key architectural decisions guiding the project's development will be presented within this context.

Additionally, the database design will be examined, with particular attention to the decision to use a NoSQL database like MongoDB. This decision was motivated by the need to adapt to the specific requirements of the project, including flexible management of unstructured data and horizontal scalability.


\section{Software Architecture}

\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.8\textwidth]{images/2_analisys/FL_proj_Arch..png}
    \caption{System Architecture}
    \label{fig:system_architecture}
\end{figure}


\newpage
\section{Database Design}

\subsection{MongoDB}
\subsubsection{Collections}
\textbf{ExpConfig document example:} \begin{verbatim}
        {
            "_id": {
              "$oid": "6613f8b7aed2e52b006dea10"
            },
            "name": "TestConfig",
            "algorithm": "fcmeans",
            "codeLanguage": "python",
            "clientSelectionStrategy": "probability",
            "clientSelectionRatio": 1,
            "minNumberClients": 2,
            "stopCondition": "max_number_rounds",
            "stopConditionThreshold": 5,
            "maxNumberOfRounds": 10,
            "parameters": {
              "targetFeature": "16",
              "lambdaFactor": "2",
              "numFeatures": "16",
              "seed": "10",
              "numClusters": "10"
            },
            "creationDate": {
              "$date": "2024-04-08T14:01:27.232Z"
            },
          }
    \end{verbatim}
\textbf{Experiment document example:} \begin{verbatim}
        {
            "_id": {
              "$oid": "661c3d780bb4be3bd9b891b9"
            },
            "name": "ExpTest",
            "expConfig": {
              "_id": {
                "$oid": "6613f8b7aed2e52b006dea10"
              },
              "name": "TestConfig",
              "algorithm": "fcmeans"
            },
            "creationDate": {
              "$date": "2024-04-14T20:32:56.022Z"
            },
            "status": "FINISHED",
            "flExpId": "\"d9d1bc7c-d733-4219-b4fb-16a3849db323\"",
            "modelPath": "\\FL_models\\exp_661c3d780bb4be3bd9b891b9.bin"
          }

    \end{verbatim}

\newpage
\textbf{ExperimentMetrics document example:} \begin{verbatim}
        {
            "_id": {
              "$oid": "66144b5337a2fd7f67582f67"
            },
            "expId": "661c3d780bb4be3bd9b891b9",
            "type": "STRATEGY_SERVER_METRICS",
            "hostMetrics": {
              "cpuUsagePercentage": 5,
              "memoryUsagePercentage": 9.27
            },
            "modelMetrics": {
              "FRO": 845.7339394664009
            },
            "timestamp": {
              "$date": "1970-01-20T19:43:26.034Z"
            },
            "round": 1,
          }
    \end{verbatim}

\textbf{User document example:} \begin{verbatim}
    {
        "_id": {
          "$oid": "6611252030f96a50aebda458"
        },
        "email": "admin@example.com",
        "password": "P@ssw0rd",
        "creationDate": {
          "$date": "2024-04-06T10:34:08.669Z"
        },
        "role": "admin",
        "configurations": [
          "6613f8b7aed2e52b006dea10"
        ],
        "experiments": [{
            "_id": {
              "$oid": "661c3e800bb4be3bd9b891da"
            },
            "name": "ExpTest",
            "config": "TestConfig",
            "creationDate": {
              "$date": "2024-04-14T20:32:56.022Z"
            }
          }]
      }

    \end{verbatim}
\newpage
\section{Message Handler}

\subsection{Erlang for Message Passing}
The message handler is implemented using the Erlang programming language. Erlang is a functional programming language designed for building scalable and fault-tolerant systems. It is particularly well-suited for building distributed systems, thanks to its lightweight processes and built-in support for message passing. In this project, it's utilized the Jinterface library, which allows to write Java code that can communicate with Erlang processes to send and receive messages, arriving from the FLang Infrastructure and vice versa.

\subsection{Message Structure}
\begin{itemize}
    \item Error Message:
          \begin{verbatim}
        {
            "type": "error",
            "cause": "error_in_collecting_data",
            "timestamp": "2024-03-13T12:34:56"
        }
    \end{verbatim}

    \item Stop Message:
          \begin{verbatim}
        {
            "type": "stop",
            "cause": "experiment_finished",
            "timestamp": "2024-03-13T12:34:56"
        }
    \end{verbatim}

    \item Data Message:
          \begin{verbatim}
        {
            "type": "data",
            "parameters": {
                "param1": "value1",
                "param2": "value2"
            },
            "timestamp": "2024-03-13T12:34:56",
            "status": "running"
        }
    \end{verbatim}
\end{itemize}

\subsection{Description of the Erlang Message Handler Module}
The Erlang message handler module is a crucial component of the system responsible for managing incoming messages, processing them accordingly, and facilitating communication between different parts of the distributed system. It encapsulates the logic for handling various types of messages, such as error notifications, stop signals, and data updates, ensuring proper routing and processing. Additionally, the module provides interfaces for sending and receiving messages, abstracting the underlying communication mechanisms and enabling seamless integration with other system components. Its robust design and fault-tolerant features contribute to the overall reliability and performance of the distributed system.